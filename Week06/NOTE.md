学习笔记
动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。

每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，

其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。

若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。

如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。

我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。

这就是动态规划法的基本思路。


动态规划问题中的“一个模型三个特征”理论讲解：

一个模型：它指的是动态规划适合解决的问题的模型。我把这个模型定义为：‘多阶段决策最优解模型’。

三个特征：最优子结构、无后效性、重复子问题。

１.　最优子结构

　　最优子结构指的是，问题的最优解包含子问题的最优解。反过来就是说，我们可以通过子问题的最优解，推导出问题的最优解。

２.　无后效性

　　无后效性有两层含义，第一层的含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。

						第二层含义是：某阶段状态一旦确定，就不受之后阶段的决策影响。

	无后效性是一个非常‘宽松’的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。


３.　重复子问题

　　不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。


两种动态规划解题思路总结：

１.　状态转移表法

　　　一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。

     从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。
	 
     找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用回溯加‘备忘录’的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决办法，状态转移表法。

public int minDistDP(int[][] matrix,int n){

int[][] states = new int[n][n];

int sum = 0;

for (int j =0;j<n;j++){

  //初始化states的第一行数据
  
　　sum += matrix[0][j];

    states[0][j] = sum;
	
}

sum = 0;

for (int i=0;i<n;++i){

   //初始化states的第一列数据
   
　　sum += matrix[i][0];

    states[i][0] = sum;
	
}

for (int i = 1;i<n;++i){

  for (int j=1;j<n;++j){
  
     states[i][j] = matrix[i][j] + Math.min(states[i][j-1],states[i-1][j]);
	 
   }
   
}

return states[n-1][n-1];

}


2.状态转移方程法

　　状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。

    有两种代码实现方法，一种是递归加‘备忘录’，另一种是迭代递推。

   状态转移方法是解决动态规划的关键。

   以下是递归加‘备忘录’的方式，将状态转移方程翻译成代码：
   
private int[][] matrix =  {{1，3，5，9}, {2，1，3，4}，{5，2，6，7}，{6，8，4，3}};
		 
private int n = 4;

private int[][] mem = new int[4][4];

public int minDist(int i, int j) { // 调用 minDist(n-1, n-1);

  if (i == 0 && j == 0) return matrix[0][0];
  
  if (mem[i][j] > 0) return mem[i][j];
  
  int minLeft = Integer.MAX_VALUE;
  
  if (j-1 >= 0) {
  
    minLeft = minDist(i, j-1);
	
  }
  
  int minUp = Integer.MAX_VALUE;
  
  if (i-1 >= 0) {
  
    minUp = minDist(i-1, j);
	
  }
  
  int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);
  
  mem[i][j] = currMinDist;
  
  return currMinDist;
  
}

